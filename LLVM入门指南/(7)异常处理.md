# 异常处理的要求
异常处理在许多高级语言中都是很常见的，在诸多语言的异常处理的方法中，try...catch块的方法是最多的。对于用返回值来做异常处理的语言(如C、Rust、Go等)来说，可以直接在高级语言层面完成所有的事情，但是，如果使用try...catch，就必须在语言的底层也做一些处理，而LLVM的异常处理则就是针对这种情况来做的。

首先，我们来看一看一个典型的使用try...catch来做的异常处理应该满足怎样的要求。C++就是一个典型的使用try...catch来做异常处理的语言，我们就来看看它的异常处理的语法:
```c++
// try_catch_test.cpp
struct SomeOtherStruct {};
struct AnotherError {};

struct foo() {
    SomeOtherStruct other_struct;
    thorw MyError();
    return;
}

void bar() {
    try {
        foo();
    } catch (MyError err) {
        // do something with err
    } catch (AnotherError err) {
        // do something with err
    } catch (...) {
        // do something
    }
}

int main ()  {
    return 0;
}
```

这是一串典型的异常处理的代码。

当遇到throw语句时，控制流会沿着函数调用栈一致向上寻找，知道找到一个try块。然后将抛出的异常与catch相比较，看看是否被捕获。如果异常没有被捕获，则继续沿着栈向上寻找，直到最终能被捕获，或者整个程序调用std::terminate结束。

按照我们上面的例子，控制流在执行bar时，首先执行foo，然后分配一个局部变量other_struct，接着遇到一个throw语句，便向上寻找，在foo函数内部没有找到try块，然后通过对比进入了第一个catch块，顺利处理了异常。

这一过程叫stack unwinding，其中有许多细节需要我们注意。

第一，是在控制沿着函数调用栈向上寻找的时候，会调用所偶有遇到的自动变量(大部分时候就是函数的局部变量)的析构函数，也就是说，在我们上面的例子里，当控制流找完了foo函数，去bar函数找之前，就会调用other_struct的析构函数。

第二，是如何匹配catch块。C++标准中给出了一长串的匹配原则，在大多数情况下，我们只需要了解，只要catch所匹配的类型与抛出的异常的类型相同，或者是引用，或者是抛出异常类型的基类，就算成功。

所以，我们总结出，使用try..catch来处理异常，需要考虑一下要求:
> + 能够改变控制流
> + 能够正确处理栈
> + 能够保证抛出的一场结构体不会因为stack unwinding而释放
> + 能够在运行时进行类型匹配

# LLVM IR的异常处理