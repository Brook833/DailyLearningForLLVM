# LLVM是什么
随着计算机技术的不断发展以及各种领域需求的增多，编程语言也逐渐丰富，同时语言的开发者往往会遇到一些相似的问题:
> + 怎么让我的编程语言能在尽可能多的平台上运行
> + 怎么让我的编程语言充分利用各个平台的优势，做到最大程度的优化
> + 怎么让我的编程语言在汇编层面实现[定制]，能够控制如符号表中的函数名、函数调用时参数的传递方法等汇编层面的概念

有的编程语言选择使用C语言来解决这种问题，如早期的Haskell等。它们将使用自己语言的源代码编译成C代码，然后再各个平台调用C编译器来生成可执行程序。

为什么要选择C作为目标代码的语言呢？有几个原因:
> + 第一，绝大部分的操作系统都是由C和汇编语言写成，因此平台大多会提供一个C编译器可以使用，这样就解决了第一个问题。
> + 第二，绝大部分的操作系统都会提供C语言的接口，以及C库。我们的编程语言因此可以很方便的调用相应的接口来实现更广泛的功能。
> + 第三，C语言本身并没有笨重的运行时，代码很贴近底层，可以使用一定程度的定制。

以上三个理由让许多编程语言开发者选择将自己的语言编译成C代码。

然而，一个平台最终运行的二进制可执行文件，实际上就是在运行与之等价的汇编代码。与汇编代码比起来，C语言还是太抽象了，我们希望能更灵活的操作一些更底层的部分。同时，我们呢也希望响应代码在各个平台能有和C语言一致，甚至更好的优化程度。

简单地说，LLVM代替了C语言在现代语言编译器实现中的地位。我们可以将自己语言的源代码编译成LLVM中间代码(LLVM IR),然后由LLVM自己的后端对这个中间代码进行优化，并且编译到相应的平台的二进制程序。

LLVM的优点正好对应我们之前讲的三个问题:
> + LLVM后端支持的平台很多，我们不需要担心CPU、操作系统的问题(运行库除外)
> + LLVM后端的优化水平较高，我们只需要将代码编译成LLVM IR，就可以由LLVM后端作相应的优化
> + LLVM IR本身比较贴近汇编语言，同时也提供了许多ABI层面的定制化功能

因为LLVM的优越性，除了LLVM自己研发的C编译器Clang，许多新的工程都选择了使用LLVM，如Rust等。

# LLVM架构
```c++
clang test.c -o test
```
究竟经历了那几个步骤？

## 前端的语法分析
我们可以使用
```c++
clang -Xclang -ast-dump -fsyntax-only test.c
```
输出我们test.c经过编译器前端的预处理、语法分析、语义分析之后，生成的抽象语法树(AST):
```c++
line:1:5 main 'int ()'
  `-CompoundStmt 0x5650ffe58280 <col:12, line:3:1>
    `-ReturnStmt 0x5650ffe58270 <line:2:2, col:9>
      `-IntegerLiteral 0x5650ffe58250 <col:9> 'int' 0
```
这才是我们源代码的AST,可以很方便的看出，经过Clang前端的预处理、词法分析、语义分析，我们的代码被分析成一个函数，其函数体是一个复合语句，这个复合语句包含一个返回语句，返回语句中使用了一个整形字面0。

**总结而言，我们基于LLVM编译器的第一步，就是将源代码转化为内存中的抽象语法树AST。**

## 前端生成中间代码
第二个步骤们就是根据内存中的抽象语法树AST生成LLVM IR中间代码(有的比较新的编译器还会先将AST转化为MLIR再转化为IR)。

我们写编译器的最终目的，是将源代码交给LLVM后端处理，让LLVM后端帮我们优化，并编译到相应的平台，而LLVM后端为我们提供的中介，就是LLVM IR。我们只需要将内存中的AST转化为LLVM IR就可以放手不管了，接下来交给LLVM后端帮我们实现。

我们先看看将AST转化之后，会产生什么样的LLVM IR:
```c++
clang -S -emit-llvm test.c
```
这时，会生成一个test.ll文件:
```c++
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  ret i32 0
}
```
这是我们AST转化为LLVM IR中最核心的部分，可以隐约感受到这个代码所表达的意思。

## LLVM后端优化IR

一个基于LLVM后端的编译器的整体过程是:
> .c --frontend--> AST
> AST --frontend--> LLVM IR
> LLVM IR --LLVM opt--> LLVM IR
> LLVM IR --LLVM llc--> .s

LLVM IR是连接编译器与LLVM后端的一个桥梁。同时，整个LLVM后端也是围绕着LLVM IR来进行的。

LLVM IR全程**LLVM Intermediate Representation**，也就是LLVM的中间表示。