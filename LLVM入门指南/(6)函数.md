在汇编层面，一个函数与一个控制语句极其相似，都是由标签组成，只不过在跳转时增加了一些附加的操作。而在LLVM IR层面，函数则得到了更高一层的抽象。

# 定义与声明
## 函数定义
在LLVM中，一个最基本的函数定义的样子我们之前已经遇到很多次，就是@main函数的样子:
```c++
define i32 @main() {
    ret i32 0
}
```

在函数名之后可以加上参数列表，如:
```c++
define i32 @foo(i32 %a, i64 %b) {
    ret i32 0
}
```

一个函数定义最基本的框架，就是返回值(i32) + 函数名(@foo) + 参数列表((i32 %a, i64 %b)) + 函数体( { ret i32 0 })。

我们可以看到，函数的名称和全局变量一样，都是以@开头的。并且，如果我们查看符号表的话，也会发现其和全局变量一样进入了符号表。因此，函数也有和全局变量完全一致的Linkage Types和Visibility Style，来控制函数名在符号表中的出现情况，因此，可以出现如:
```c++
define private i32 @foo() {
    ; ...
}
```
这样的修饰符

此外，我们还可以在参数列表之后加上之前说的属性，也就是控制优化器和代码生成器的指令。在之前讲属性组的时候，可以在@foo函数之后跟上一个属性组#0。

我们通过对一个函数附加诸多属性，来控制最终的优化和代码生成。大部分的属性可以在Function Attributes一节看到。

## 函数声明
除了函数定义之外，还有一种情况十分罕见，那就是函数声明。我们在一个编译单元(模块)下，可以使用别的模块的函数，这时候就需要在本模块先声明这个函数，才能保证编译时不出错，从而在链接时正确将声明的函数与别的模块下其定义进行链接。

==函数声明也比较简单，就是使用declare关键词替换define==
```c++
declare i32 @printf(i8*, ...) #1
```
这个就是在C代码中调用stdio.h库的printf函数时，在LLVM IR代码中看到的函数声明，其中#1就是一大串属性组成的属性组。

# 函数的调用
在LLVM IR中，函数的调用与高级语言几乎没有什么区别:
```c++
define i32 @foo (i32 %a){
    ; ...
}

define void @bar() {
    %1 = call i32 @foo(i32 1)
}
```

使用call指令可以像高级语言那样直接调用函数。我们来仔细分析一下这里做了哪几件事:
> + 传递参数
> + 执行函数
> + 获得返回值

# 执行函数
我们知道，如果一个函数没有任何参数，返回值也是void类型，也就是说在C语言下这个函数是:
```c++
void foo () {
    //...
}
```
那么调用这个函数就没有了传递参数和获得返回值这两件事，只剩下执行函数，而这是一个最简单的事:
> + 把函数返回地址压栈
> + 跳转到相应函数的地址

函数返回也是一个简单的事:
> + 弹栈获得函数返回地址
> + 跳转到相应的返回地址

# 传递参数与获得返回值
谈到这两点，就不得不说调用约定了。我们知道，在汇编语言中，是没有参数传递和返回值的概念的，有的仅仅是让当前的控制流跳转到指定函数执行。所以，一切的参数传递和返回值都需要我们人为约定，也就是说，我们需要约定两件事:
> + 被调用的函数希望知道函数是放在哪里的
> + 调用者希望知道调用函数的返回值是放在哪里的

这就是调用约定。不同的调用约定会产生不同的特效，也就产生了许多高级语言的feature。

## C调用约定
最广泛使用的调用约定是C调用约定，也就是各个操作系统的标准库使用的调用约定。在x86_64架构下，C调用约定是System V版本的，所有参数按顺序放入指定寄存器，如果寄存器不够，剩余的参数从右往左顺序压栈。而返回值则是按先后顺序放入寄存器或者调用者分配的空间中，如果只有一个返回值，那么就会放在rax里。

在LLVM IR中，函数的调用默认使用C调用约定。

这种System V的调用约定有什么好处呢？
其最大的特点在于，当寄存器数量不够时，剩余的参数时从右向左的顺序压栈，这就让基于这种调用约定的高级语言可以更轻松地实现可变参数的feature。所谓可变参数，最典型的例子就是C语言中的printf:
```c++
printf("%d %d %d %d", a, b, c, d);
```

printf可以接受任意数量的参数，其参数的数量是由第一个参数"%d %d %d %d"决定的，有多少个需要格式化的变量，接下来就有多少个参数。

那么System V的调用约定为什么能满足这种需求呢？
假设我们不考虑之前传入寄存器内的参数，只考虑压栈的参数，那么，我们的程序就可以先读栈顶"%d %d %d %d"的地址，接着依次是a,b,c,d。那么，我们的程序就可以先读栈顶，获得字符串，然后确定有多少个参数，接着就是继续在栈上读有多少个参数。相反，如果是从左往右顺序压栈，那么程序第一个读到的是d,程序也不知道该读多少个参数。

## fastcc
各种语言的调用约定还有许多，可以参考语言指南的Calling Conventions一节。

fastcc方案是将变量全部传入寄存器中的方案。这种方案使尾调用优化能更方便的实现。

尾调用会出现在很多场景下，用一个比较常见的例子:
```c++
int foo(int a) {
    if (a == 1) {
        return 1;
    } else {
        return foo(a - 1);
    }
}
```

我们注意到，这个函数是在返回时会调用自身，这就叫尾调用。
为什么尾调用需要优化呢？
我们知道，在正常情况下，调用一个函数会产生函数的栈帧，也就是把函数的参数传入栈，把函数的返回地址传入栈。那么如果a很大，那么调用的函数会越来越多，并且知道最后一个被调用的函数返回之前，所有调用的函数的栈都不会回收，也就是说，我们此时栈上充斥着一层一层被调用函数返回的地址。

然而，由于这个函数是在调用者的返回语句里调用，我们实际上可以复用调用者的栈，这就是尾调用优化的基础思想。我们希望，把这样的尾调用变成循环，从而减少栈的使用，通过将参数都传入寄存器，我们呢可以避免再将参数传入栈，这就是fastcc为尾调用优化提供的帮助。然后，就可以直接将函数调用变成汇编中的jmp。

## 栈指针清除优化
再讲一个函数调用中的优化，就是栈指针清除优化(Frame Pointer Elimination)。
在将这个之前，先讲一个比较小的优化。

```c++
void foo(int a, int b) {}
int main() {
    foo(1, 2);
    return 0;
}
```
编译为汇编程序，可以发现，foo函数的汇编代码为:
```c++
_foo:
    pushq   %rbp
    movq    %rsp, %rbp
    movl    %edi, -4(%rbp)
    movl    %esi, -8(%rbp)
    popq    %rbp
    retq
```
与我们的常识有些违背。为啥这里栈不先增加(也就是对rsp寄存器进行sub)，就直接把rdi，esi的值移入栈内？-4(%rbp)和-8(%rbp)的内存空间此刻似乎并不属于栈。这是因为，我们对栈指针进行操作，一个很重要的原因就是为了进一步函数调用的时候，使用call指令会自动将被调用函数的返回地址压栈，那么就需要在call指令之前，保证栈顶指针确实指向栈顶，否则压栈就会覆盖一些数据。

但此时，我们的foo函数并没有调用别的函数，也就不会产生压栈行为，从而编译器为我们省去了这样的操作。为了验证这一点，我们做一个小的修改:
```c++
void bar() { }
void foo(int a, int b) { bar(); }
int main() {
    foo(1, 2);
    return 0;
}
```

这时，我们再看编译出的foo函数的汇编代码:
```c++
_foo:
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp
    movl    %edi, -4(%rbp)
    movl    %esi, -8(%rbp)
    callq   _bar
    addq    $16, %rsp
    popq    %rbp
    retq
```

确实增加了对rbp的sub和add操作，而此时的bar函数，也没有对rsp的操作。
接下来，就要讲帧指针清除优化了。经过上面的例子，一个函数再进入时会有一些固定动作:
> + 1.把rbp压栈
> + 2.把rsp放入rbp
> + 3.减rsp，预留栈空间

再函数返回之前，也有其相应的操作:
> + 1.加rsp，回收栈空间
> + 2.把rbp最初的值弹栈回到rbp

帧指针清除再LLVM IR层面其实十分方便，就是什么都不写:
```c++
define void @foo(i32 %a, i32 %b) {
    %1 = alloca i32
    %2 = alloca i32
    store i32 %a, i32* %1
    sotre i32 %b, i32* %2
    ret void
}
```
这个函数再编译成汇编语言之后，是:
```c++
_foo:
    movl    %edi, -4(%rsp)
    movl    %esi, -8(%rsp)
    retq
```

不仅没有了栈的增加减少，也没有了对rbp的操作(帧指针清除)。

要想恢复这一操作也十分简单，在函数列表后加一个属性"frame-pointer" = "all":
```c++
define void @foo(i32 %a, i32 %b) "frame-pointer"="all" {
    %1 = alloca i32
    %2 = alloca i32
    store i32 %a, i32* %1
    store i32 %b, i32* %2
    ret void
}
```

其编译后的汇编程序就是:
```c++
_foo:
    pushq   %rbp
    movq    %rsp, %rbp
    movl    %edi, -4(%rbp)
    movl    %esi, -8(%rbp)
    popq    %rbp
    retq
```
