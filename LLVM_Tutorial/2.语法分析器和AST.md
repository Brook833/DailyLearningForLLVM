# 2 语法分析器和AST
在解析"万花筒"的语法时，我们将综合运用递归下降解析和运算符优先解析两种技术(后者用于解析二元表达式，前者用于其他部分)。

正式解析前，不妨看一看解析器的输出:抽象语法树。

## 2.1 抽象语法树(AST)
抽象语法树的作用在于牢牢抓住程序的脉络，从而方便编译过程的后续环节(如代码生成)对程序进行解读。

**AST就是开发者为语言量身定制的一套模型，基本上语言的每种结构都与一种AST对象相对应。**

"万花筒"语言中的语法结构包括表达式、函数原型和函数对象，我们不妨从表达式入手:
```c++
// ExprAST - Base class for all expression nodes
class ExprAST {
public:
    virtual ~ExprAST(){}
};

// NumberAST - Expression class for numeric literals like "1.0".
class NumberExprAST : public ExprAST {
    double Val;
public:
    NumberExprAST(double val) : Val(val) {}
};
```

上述代码定义了基类ExprAST和一个用于表示数值常量的子类。其中子类NumberExprAST将数值常量的值存放在成员变量中，已备编译器后续查询。

直到目前为止，我们还只搭出AST的架子，尚未定义任何能够体现AST实用价值的成员方法。
例如，只需添加一套虚方法，我们就可以轻松实现代码的格式化打印。
以下定义了"万花筒"语言最基本的部分所要用到的其他各种表达式的AST结点:
```c++
// VariableExprAST - Expression class for referencing a variable, like "a".
class VariableExprAST : public ExprAST {
    std::string Name;
public:
    VariableExprAST(const std::string &name) : Name(name) {}
};

// BinaryExprAST - Expression class for a binary operator.
class BinaryExprAST : public ExprAST {
    char Op;
    ExprAST *LHS, *RHS;
public:
    BinaryExprAST(char op, ExprAST *lhs, ExprAST *rhs) : Op(op), LHS(lhs), RHS(rhs) {}
};

// CallExprAST - Expression class for function calls
class CallExprAST : public ExprAST {
    std::string Callee;
    std::vecotr<EprAST *> Args;
public:
    CallExprAST(const std::string &callee, std::vector<ExprAST *> &args) : Callee(callee), Args(args) {}
};
```
将这几个类设计的简单明了:
> + VariableExprAST用于保存变量名
> + BinaryExprAST用于保存运算符(如“+”)
> + CallExprAST用于保存函数名和用作参数的表达式列表。

这样设计AST有一个优势，那就是我们无须关注语法便可直接抓住语言本身的特性。
注意这里还没有涉及二元运算符和词法结构等问题。

定义完毕这几种表达式结点，就足以描述"万花筒"语言中的几个最基本的结构了。由于我们呢还没有实现条件控制流程，他还不算图灵完备，后续还会加以完善。接下来，还有两种结构需要描述，即函数的接口和函数本身:
```c++
// PrototypeAST - 此类表示函数原型，捕获其名称和参数名称
class PrototypeAST {
    std::string Name;
    std::vecotr<std::string> Args;
public:
    PrototypeAST(const std::string &name, const std::vecotr<std::string> &args) : Name(name), Args(args) {}
};

// FunctionAST - 此类表示函数定义本身。
class FunctionAST {
    PrototypeAST *Protr;
    ExprAST *Body;
public:
    FunctionAST(PrototypeAST *protr, ExprAST *body) : Protr(proty), Body(body) {}
};
```

在"万花筒"中，函数的类型是由参数的个数决定的，由于所有的值都是双精度浮点数，没有必要保存参数的类型。在更强大、更实用的语言中，ExprAST还会需要一个类型字段。

## 2.2语法解析器基础
开始构造AST之前，先要准备好用于构造AST的语法解析器。说白了，就是要利用语法解析器把"x + y"这样的输入(由词法分析器返回的三个token)分解成有下列代码组成的AST:
```c++
ExprAST *X = new VariableExprAST("x");
ExprAST *Y = new VariableExprAST("y");
ExprAST *Result = new BinaryExprAST('+', X, Y);
```

为此，我们先定义几个辅助函数:
```c++
// CurTok/getNextToken - 提供一个简单的token缓冲区
// CurTok - 是解析器正在查看的token
// getNextToken - 从词法分析器读取另一个token，并用其结果更新CurTok
static int CurTok;
static int getNextToken() {
    return CurTok = gettok();
}
```

这段代码以词法分析器为中心，实现了一个简易的语元缓冲，让我们能够预先读取词法分析器下一个将要返回的token。在我们的语法解析器中，所有函数都将CurTok视作当前待解析的token。

```c++
// Error - 这些是用于错误处理的工具函数
ExprAST *Error(const char *Str) {
    fprintf(stderr, "Error: %s\n", Str);
    retrun 0;
}

ProtorypeAST *ErrorP(const char *Str) {
    Error(Str);
    return 0;
}

FunctionAST *ErrorF(const char *Str) {
    Error(Str);
    return 0;
}
```
这三个用于报错的辅助函数也很简单，我们的语法解析器将用它们来处理解析过程中发生的错误。这里采用的错误恢复策略并不妥当，对用户也不怎么友好，但对于教程而言也就够用了。

示例代码中各个函数的返回值类型各不相同，有了这几个函数，错误处理就简单了:它们的返回值都是Null。

准备好这几个辅助函数之后，我们就开始实现第一条语法规则:数值常量。

## 2.3 解析基本表达式
之所以从数值常量下手，是因为它最简单。
**"万花筒"语法中的每一条生成规则(production)，都需要一个对应的解析函数。**
对于数值常量，就是:
```c++
// numberexpr :: =number
static ExprAST *ParseNumberExpr() {
    ExprAST *Result = new NumberExprAST(NumVal);
    getNextToken();
    return Result;
}
```
这个函数很简单，调用它的时候，当前待解析语元只能是tok_number。
该函数用刚解析出来的数值构造出了一个NumberExprAST节点，然后令词法分析器继续读取下一个token，最后返回构造的AST节点。

这里有几处很有意思，其中最显著的便是该函数的行为，它不仅消化了所有与当前生成规则相关的所有token，还把下一个待解析的token放进了词法分析器的token缓冲中(该token与当前的生成规则无关)。这时非常标准的递归下降解析器的行为。下面这个括号运算符的例子更能说明问题:
```c++
// parenexpr ::='('expression')'
static ExprAST *ParseParenExpr() {
    getNextToken();  // eat(
    ExprAST *V = ParseExpression();
    if (!V) {
        return 0;
    }
    if (CurTok != ')') {
        return Error("expected')'");
    }
    getNextToken();  // eat)
    return V;
}
```
该函数展示了这个语法解析器的几个特点:
> + 1.它展示了Error函数的用法。调用该函数时，待解析的token只能是"(",然而解析完子表达式后，紧跟着的token不一定是")"。比如，要是用户输入的是"(4 x "而不是"(4)",语法解析器就应该报错。既然错误时有发生，语法解析器就必须提供另一条报告错误的途径，就这个词法解析器而言，应对之道就是返回NULL。
> + 2.该函数的另一特点在于递归调用了ParseExpression(很快我们就会看到ParseExpression还会反过来调用ParseParenExpr)。这种手法简化了递归语法的处理，每一条生成规则的实现都得以变得非常简洁。需要注意的是，我们没必要为括号构造AST节点。虽然这么做也没错，但括号的作用主要还是对表达式进行分组进而引导语法解析过程。当语法解析器构造完成之后，括号就没用了。

下一条生成规则也很简单，它负责处理变量引用和函数调用:
```c++
// identifierexpr
// ::=identifier
// ::=identifier '('expression*')'
static ExprAST *ParseIdentifierExpr() {
    std::string IdName = IdentifierStr;
    getNextToken();  // eat identifier
    if (CurTok != '(')  // 简单变量引用
        return new VariableExprAST(IdName);
    
    // 函数调用
    getNextToken();  // eat (
    std::vecotr<ExprAST *> Args;
    if (CurTok != ')') {
        while (1) {
            ExprAST *Arg = ParseExpression();
            if (!Arg) {
                return 0;
            }
            Args.push_back(Arg);

            if (CurTok == ')') {
                break;
            }

            if (CurTok != ',') {
                return Error("Expected ')' or ',' in argument list");
            }
            getNextToken();
        }
    }
}
```

该函数与其他函数风格别无二致。(调用该函数时当前token必须是tok_identifier)前文提到的有关递归和错误处理的特点它统统具备。有意思的是这里采用了预读(lookahead)的手段来试探当前标识符的类型，判断它究竟是个独立的变量引用还是个函数调用。只要检查紧跟标识符之后的token是不是"(",就能直到到底应该构造VariableExprAST节点还是CallExprAST节点。

现在，解析各种表达式的代码都已经完成，不妨再添加一个辅助函数，为他们梳理一个统一的入口。我们将上述表达式称为主表达式(primary expression)，具体原因参见本教程的后续章节。在解析各种主表达式时，我们首先要判定带解析表达式的类型:
```c++
// primary
// ::= identifierexpr
// ::= numberexpr
// ::= parenexpr
static ExprAST *ParsePrimary() {
    switch(CurTok) {
        default: return Error("unknown token when exprcting an expression");
        case tok_identifier: return ParseIdentifierExpr();
        case tok_number: return ParseNumberExpr();
        case '(': return ParseParpenExpr();
    }
}
```
看完这个函数定义，你就能明白为什么先前的各个函数能够放心大胆的对CurTok的取值作出假设了。这里与读了下一个token，预先对待解析表达式的类型做出了判断，然后才调用的函数进行解析。

基本表达式全都搞定了，下面开始着手解析更为复杂的二元表达式。

## 2.4 解析二元表达式
二元表达式的解析难度要大得多，因为它们往往具有二义性。例如，给定字符串"x+y* z"，语法解析器既可以将之解析为"(x+y)*z"，也可以将之解析为"x+(y *z)"。按照通常的数学定义，我们期望解析成后者，因为乘法的优先级要高于加法。

这个问题的解法很多，其中运算符优先级解析最为高雅和高效。
这是一种利用二元运算符的优先级来引导递归调用走向的解析技术。
首先，我们需要制定一张优先级表:
```c++
// BinopPrecedence - 二进制运算符优先级
static std::map<char, int> BinopPrecedence;

// GetTokPrecedence - 获取二进制运算符优先级
static int GetTokPrecedence() {
    if (!isascii(CurTok)) {
        return -1;
    }
    // 确保它是声明的二进制操作
    int TokPrec = BinopPrecedence[CurTok];
    if (TokPrec <= 0) {
        return -1;
    }
    return ToPrec;
}

int main() {
    // 1是最低优先级
    BinopPrecedence['<'] = 10;
    BinopPrecedence['+'] = 20;
    BinopPrecedence['-'] = 20;
    BinopPrecedence['*'] = 40;
    ...
}
```
最基本的"万花筒"语言仅支持4种二元运算符。

函数GetTokPrecedence用于查询当前token的优先级，如果当前token的不是二元运算符则返回-1。

这里的map简化了新运算符的添加，同时也证明我们的算法与具体的运算符无关。当然，要想去掉map直接在GetTokPrecedence中比较优先级也很简单。(甚至可以直接使用定长数组)。

有了上面的函数作为辅助，我们就可以开始解析二元表达式了。运算符优先级解析的基本思想就是通过拆解含有二元运算符的表达式来解决可能的二义性问题。以表达式"a+b+(c+d)* e * f+g"为例，在进行运算符优先级解析时，它将被视作一串按二元运算符分隔的主表达式。按照这个思路，解析出来的第一个主表达式应该是"a"，紧跟着是若干个有序对，即[+, b]、[+,(c+d)]、[*,e]、[*,f]、[+,g]。注意，括号表达式也是主表达式，所以在解析二元表达式时无需照顾(c+d)这样的嵌套表达式。

一开始，每个表达式都由一个主表达式打头阵，身后可能还跟着一串有序对构成的列表，其中有序对的格式为[binop,primaryexpr]:
```c++
// expression
static ExprAST *PareExpression() {
    ExprAST *LHS = ParsePrimary();
    if(!LHS) return 0;
    return ParseBinOpRHS(0, LHS);
}
```