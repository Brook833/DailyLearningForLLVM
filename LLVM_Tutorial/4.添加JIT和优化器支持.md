# 4 添加JIT和优化器支持
向语言添加优化器支持和添加JIT编译器支持

## 4.1 琐碎的常数折叠
第三章中生成的代码是优雅的，并且易于拓展的。但它不能生成出色的代码。不过，再编译简单代码时，IRBuilder确实为我们提供了明显的优化:

```c++
ready> def test(x) 1+2+x;
Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 3.000000e+00, %x
        ret double %addtmp
}
```

此代码不是通过解析输入构建的AST的文字转录。那就是:

```c++
ready> def test(x) 1+2+x;
Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 2.000000e+00, 1.000000e+00
        %addtmp1 = fadd double %addtmp, %x
        ret double %addtmp1
}
```

特别是如上所述，常量折叠是一种非常常见且非常重要的优化:如此之多，以至于许多语言的是闲者在其AST表示中实现了常量折叠支持。

使用LLVM，您在AST中不需要这种支持。因为构建LLVM IR的所有调用都要通过LLVM IR生成器，所以当您调用它时，生成器本身是否会检查是否存在常量折叠机会。如果有，它只执行常量折叠并返回常量，而不是创建指令。

实际上，我们建议在生成这样的代码时始终使用IRBuilder。它的使用没有"语法开销"(不必再任何地方通过常量检查使编译器丑化)，并且它可以极大的减少在某些情况下生成的LLVM IR的数量(特别是对于带有宏预处理器的语言或使用大量常量的语言)。

另一方面，"IRBuilder"受到这样一个事实的限制，即它在构建时所有的分析都与代码内联。如果举一个稍复杂一点的示例:

```c++
ready> def test(x) (1+2+x)*(x+(1+2));
ready> Read function definition:
define double @test(double %x) {
entry:
    %addtmp = fadd double 3.000000e+00, %x
    %addtmp1 = fadd double %x, 3.000000e+00
    %multmp = fmul double %addtmp, %addtmp1
    ret double %multmp
}
```

在这种情况下，乘法的LHS和RHS是相同的值。我们非常希望看到它生成"tmp = x + 3; result = tmp*tmp;",而不是计算"x+3"两次。

不行的是，任何数量的本地分析都无法检测和纠正这一点。这需要两个转换，表达式的重新关联(以使加法的词法相同)和公共子表达式消除(CSE)以删除冗余的加法指令。幸运的是，LLVM以"pass"的形式提供了一系列可以使用的有优化。

## 4.2 LLVM优化pass