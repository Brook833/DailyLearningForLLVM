# 3 LLVM IR代码生成
## 3.1 代码生成的准备工作
在开始生成LLVM IR之前，还有一些准备工作要做。首先，给每个AST类添加一个虚函数Codegen(Code generation),用于实现代码生成:
```c++
class ExprAST {
public:
    virtual ~ExprAST() {}
    virtual Value *Codegen() = 0;
};

class NumberExprAST : public ExprAST {
    double Val;
public:
    NumberExprAST(double val) : Val(val) {}
    virtual Value *Codegen();
};
...
```

每个AST节点的Codegen()方法负责生成该类型AST节点的IR代码及其他必要信息，生成的内容以LLVM Value对象的形式返回。LLVM用"Value"类表示"静态一次性赋值(SSA,Static Single Assignment)寄存器"或"SSA值"。

SSA值最为突出的特点就在于"固定不变":
> + SSA值经由对应指令运算得出后便固定下来，直到该指令再次执行之前都不可修改。

除了在ExprAST类体系中添加虚方法以外，还可以利用visitor模式等其他方法来实现代码生成。再次强调，本教程不拘泥于软件工程实践层面的优劣，就当前需求而言，添加虚函数是最简单的方案。

其次，我们还需要一个"Error"方法，该方法与语法解析器里用到的报错函数类似，用于报告代码生成过程中发生的错误(例如引用了未经声明的参数):
```c++
Value *ErrorV(const char *Str) { Error(Str); return 0;}

static Module *TheModule;
static IRBuilder<> Builder(getGlobalContext());
static std::map<std::string, Value*> NamedValues;
```

上述几个静态变量都是用于完成代码生成的。

其中TheModule是LLVM中用于存放代码段中所有函数和全局变量的结构。从某种意义上来讲，可以把它当作LLVM IR代码的顶层容器。

Builder是用于简化LLVM指令生成的辅助对象。IRBuilder类模板的示例可用于跟踪当前插入指令的位置，同时还带有用于生成新指令的方法。

NamedValues映射表用于记录定义于当前作用域内的变量及与之相对应的LLVM表示(换言之，也就是代码的符号表)。可引用的变量只有函数的参数。因此，在生成函数体的代码时，函数的参数就存放在这张表中。

有了这些，就可以开始进行表达式的代码生成工作了。注意，在生成代码之前必须先设置好Builder对象，指明写入代码的位置。现在，我们姑且假设已经完事俱备，专心生成代码即可。

# 3.2 表达式代码生成
为表达式节点生成LLVM代码的过程十分简单明了，首先是数值常量:
```c++
Value *NumberExprAST::Codegen() {
    return ConstantFP::get(getGlobalContext(), APFloat(Val));
}
```

LLVM IR中的数值常量是由ConstantFP类表示的。在其内部，具体数值由APFloat(Arbitary Precision Float，可用于存储任意精度的浮点数常量)表示。

这段代码说白了就是新建并返回一个ConstatFP对象。值得注意的是，在LLVM IR内部，常量都只有一份，并且是共享的。因此，API往往会采用"foo:get(...)"的形式而不是"new foo(...)"或"foo::Create(...)"。

```c++
Value *VariableExprAST::Codegen() {
    Value *V = NamedValues[Name];
    return V ? V: ErrorV("Unknow variable name");
}
```
在LLVM中引用变量也很简单，在简化版的万花筒中，我们大可假设被引用的变量已经在某处被定义并赋值。实际上，位于NamedValues映射表中的变量只可能是函数的调用参数。这段代码首先确认我们给定的变量名是否存在于映射表中(如果不存在，就说明引用了未定义的变量)然后返回该变量的值。后续，我们还会对语言做进一步扩展，让符号表支持"循环归纳变量"和"局部变量"。

```c++
Value *BinaryExprAST::Codegen() {
    Value *L = LHS->Codegen();
    Value *R = RHS->Codegen();
    if (L == 0 || R == 0) {
        return 0;
    }

    switch (Op) {
        case '+': return Builder.CreateFAdd(L, R, "addtmp");
        case '-': return Builder.CreateFSub(L, R, "sumtmp");
        case '*': return Builder.CreateFMul(L, R, "multmp");
        case '<':
            L = Builder.CreateFCmpTLT(L, R, "cmptmp");
            // 将布尔值0/1转换为双精度0.0/1.0
            return Builder.CreateUIToFP(L, Type::getDoubleTy(getGlobalcontext(), "booltmp"));
        default:
            return Error("无效的运算符");
    }
}
```
二元运算符的处理就比较有意思了。其基本思想是递归地生成代码，先处理表达式的左侧，在处理表达式的右侧，最后计算整个二元表达式的值。上述代码就"opcode"的取值用了一个最简单的switch语句，从而为各种二元运算符创建出相应的LLVM指令。

在上面的例子中，LLVM的Builder类逐渐开始凸显出自身的价值。你只需想起出该用哪些操作数(即此处的L和R)生成哪条指令(通过调用CreateFAdd等方法)即可，至于新指令该插到什么位置，交给IRBuilder就可以了。此外，如果需要，你还可以给生成的指令指定一个名字。

LLVM的优点之一在于此处的指令名只是一个提示。举个例子，假设上述代码生成了多条addtmp指令，LLVM会自动给每条指令的名字追加一个自增的唯一数字后缀。指令的local value name完全是可选的，但他能大大提升dump出来的IR代码的可读性。

LLVM指令遵循严格的约束:例如，add指令的Left、Right操作数必须同属一个类型，结果的类型则必须与操作数的类型相容。由于万花筒中的值都是双精度浮点数，add、sub和mul指令的代码得以大大简化。

然而，LLVM要求fcmp指令的返回值必须是i1(单比特整数)。问题在于万花筒只能接受0.0或1.0。为了弥合语义上的差异，我们给fcmp指令配上一条uitofp指令。这条指令会将输入的整数视作无符号数，并将其转换成浮点数。

```c++
Value *CallExprAST::Codegen() {
    // 在全局模块表中查找名称
    Function *CalleeF = TheModule->getFunction(Callee);
    if (CalleeF == 0) {
        return ErrorV("未知的函数");
    }

    // 如果参数不匹配
    if (CalleeF->arg_size() != Args.size()) {
        return ErrorV("传递的参数不正确");
    }

    std::vector<Value *> ArgsV;
    for(unsigned i = 0, e = Args.size(); i != e; i++) {
        ArgsV.push_back(Args[i]->Codegen());
        if (ArgsV.back() == 0) {
            return 0;
        }
    }

    return Builder.CreateCall(CalleeF, ArgsV, "calltmp");
}
```

函数调用的代码生成非常直接了当。上述代码开头的几行是在LLVM Module的符号表中查找函数名。如前文所示，Module是个容器，待处理的函数全都在里面。只要保证各函数的名字与用户指定的函数名一致，我们就可以利用LLVM的符号表替我们完成函数名的解析。

拿到待调用的函数之后，就递归地生成传入的各个参数的代码，并创建一条LLVM call指令。注意，LLVM默认采用本地的C调用规范，这样以来，就可以毫不费力的调用标准库中的"sin"、"cos"等函数了。

